---
title: Baseline Patterns
---

{% include "toc.html" %}

It is useful to have some common baseline patterns to follow when using a very open ontology, like CIDOC-CRM.  From working with datasets from across many different museums, the following patterns have been agreed on as useful ways to think about our cultural data.

These patterns are presented below with examples of how they are used in practice, but these are not intended to be exhaustive.  The documentation for the different resource types will include more information about how they are used in different circumstances.

## Core Properties

There are a few core properties that every resource should have for it to be a useful part of the world of Linked Open Data:

* `id` captures the URI that identifies the object.  Every resource must have exactly one id, and it must be an HTTP URI.
* `type` captures the class of the object, or `rdf:type` in RDF. Every resource must have exactly one class. This allows software to align the data model with an internal, object oriented class based implementation.
* `_label` captures a human readable label as a string, intended for developers or other people reading the data to understand what they are looking at.  Every resource should have exactly one label, and must not have more than one.

Example:  The simplest possible object.

```crom
top = ManMadeObject()
top._label = "Example Object"
```

## Types and Classifications

The CRM is a framework that must be extended via additional vocabularies and ontologies to be useful.  The provided mechanism for doing this is the predicate `crm:P2_has_type`, mapped as `classified_as` in the model. The semantics of `crm:P2_has_type` are closer to "is classified as" or perhaps "has semantic tag", rather than "is an instance of the class" like `rdf:type` (mapped as `type` in the model). The `type` field is used for CRM defined classes, and as few other extensions as possible.

While any external vocabulary of terms can be used, the Getty Vocabularies are used whenever possible for consistency. The set of terms that have been identified as useful from those vocabularies is listed in the [community best-practices](/community/best-practices/vocabularies/).

Use cases for this pattern are in almost every example, but include:

 * The object being an art object
 * The type of an art object being a painting
 * The type of a description being a materials statement
 * The type of an identifier being an accession number
 * The type of an organization being a museum
 * The type of a place being a gallery

__Example:__

The type of the object (an instance of `ManMadeObject`) is a painting _(aat:300033618)_:

Example: An object is a painting and a work of art.

```crom
top = Painting(art=1)
top._label = "Simple Example Painting"
```

## Names and Identifiers for a Resource

### Names

As the `_label` property is intended as internal documentation for the data, it is strongly recommended that every resource that should be rendered to an end user as an item of interest also have at least one specific name. This name could be for an object, a person, a group, an event or anything else.  This pattern uses the `identified_by` property, with a `Name` resource.  The value of the name is given in the `content` property of the `Name`. 

It is somewhat unintuitive to think of a name as identifying the resource it is associated with, as names are typically not unique.  However, as the name itself __is__ uniquely identified rather than just an anonymous string, they are no longer a shared label and instead the particular instance of a name is uniquely associated with the resource. With this formulation, the name instance does uniquely identify the resource.  

If there is more than one name given, then there should be one that is `classified_as` the primary name for use. This is done by adding the Primary Name _(aat:300404670)_ term to it.

Names are also part of language, and can have the Linguistic features of the model associated with them, such as being in a language, or having translations.

Example:  The primary name for the painting is "Pasture and Sheep", which is in English.

```crom
top = Painting(art=1)
top._label = "Painting: Pasture and Sheep"
ttl = PrimaryName()
ttl.content = "Pasture and Sheep"
ttl.language = instances['english']
top.identified_by = ttl
```

### Identifiers

Many resources of interest are also given external identifiers, such as Accession Numbers for objects, ORCIDs for people or groups, lot numbers for auctions, and so forth.  Identifiers are represented in a very similar way to names, but instead use the `Identifier` class. Identifiers will normally have a classification determining which sort of identifier it is, to distinguish between internal repository system assigned numbers from museum assigned accession numbers, for example.

As Identifiers and Names use the same `identified_by` property, the JSON will frequently have mixed classes in the array. Unlike Names, Identifiers are not part of human language and thus cannot have translations or a language associated with them.

Example:  The Accession Number identifier for the painting is "P1998-27".

```crom
top = Painting(art=1)
top._label = "Painting: Pasture and Sheep"
id1 = AccessionNumber()
id1.content = "P1998-27"
top.identified_by = id1
ttl = PrimaryName()
ttl.content = "Pasture and Sheep"
top.identified_by = ttl
```

## Statements about a Resource

In many cases, current data does not support the level of specificity that the full ontology allows, or the information is simply best expressed in human-readable form.  For example, instead of a completely modeled set of parts with materials, many museum collection management systems allow only a single human-readable string for the "medium" or "materials statement".  The same is true in many other situations, including rights or allowable usage statements, dimensions, edition statements and so forth.  Any time that there is a description of the resource, with or without qualification as to the type of description, then this pattern can be used to record the descriptive text.

The pattern makes use of the Linguistic Object class that is used to identify a particular piece of textual content.  These Linguistic Objects are then refered to by any other resource.  They maintain the statement's text in the `content` property, and the language of the statement (if known) in the `language` property.

Use cases for this pattern include:

* General description of the resource
* Materials statement for an object
* Attribution statement for an image
* Biography for a person
* Dimensions statement for a part of an object

Example: Having only a textual description of the materials in English, the content `"Oil on Canvas"` is recorded as referring to the painting as a "materials" _(aat:300010358)_ statement:

```crom
top = Painting(art=1)
top._label = "Example Painting on Canvas"
lo = MaterialStatement(top.id + "/statement/1")
lo.content = "Oil on Canvas"
lo.language = instances['english']
top.referred_to_by = lo
```

## Parts

Describing the hierarchy of parts of resources is a core pattern for having increasingly granular or specific descriptions. These partitionings can be physical (the frame is part of the painting), temporal (World War Two is part of the modern era), linguistic (the first chapter is part of the manuscript's text), or more closely related to membership in a set (the painting is part of the collection). The advantage of partitioning is that more specific information can be provided about each part, as a thing separate from the whole.

Example: The painting is a watercolor, and the support on which it is found is made of canvas.

```crom
top = Painting(art=1)
top._label = "Example Painting"
top.made_of = instances['watercolor']
part = SupportPart(top.id + "/part/1")
part._label = "Canvas Support"
part.made_of = instances['canvas']
top.part = part
```

Similary, a distinction between the abstract information content and the physical carriers of that content gives us the ability to physically partition objects and logically partition the text or image content, without having strong dependencies between the two. 

Example: The content of the first ledger from a dealer's records contains the content of the first row of that ledger.

```crom
top = LinguisticObject()
top._label = "Content of Ledger 1"
row = LinguisticObject(top.id + "/part/1")
row._label = "Content of Row 1"
top.part = row
```
